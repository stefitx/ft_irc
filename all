#include "../inc/Channel.hpp"
# include "../inc/Client.hpp"
# include "../inc/Server.hpp"


Channel::Channel(std::string name) {
	_name = name;
	_clientNum = 0;
	_password = "";
	_userLimit = 0;
	_chanOperator = NULL;
	_topic = "";
	_mode = "";
	_accessType = "";
	_invitedMembers.clear();
	_passwordMode = false;
	_inviteMode = false;
	_topicRestrictionMode = true;
	_operPrivilegeMode = false;
	_userLimitMode = false;
	//members = std::map<int, Client *>();
}

Channel::Channel(const Channel &other) :
	_name(other._name),
	_password(other._password),
	_clientNum(other._clientNum),
	_topic(other._topic),
	_userLimit(other._userLimit),
	_invitedMembers(other._invitedMembers),
	_mode(other._mode),
	_chanOperator(other._chanOperator),
	_accessType(other._accessType),
	_members(other._members),
	_operators(other._operators)
{}

Channel::~Channel() {}

Channel &Channel::operator=(const Channel &other) {
	if (this != &other) {
		_name = other._name;
		_clientNum = other._clientNum;
		_chanOperator = other._chanOperator;
		_userLimit = other._userLimit;
		_topic = other._topic;
		_password = other._password;
		_mode = other._mode;
		_accessType = other._accessType;
		_members = other._members;
		_operators = other._operators;
		_invitedMembers = other._invitedMembers;
	}
	return *this;
}

void	Channel::broadcast(std::string msg, Client &except)
{
	for(std::map<std::string, Client *>::iterator it = _members.begin(); it != _members.end(); ++it)
	{
		if (it->first != except.getNick()) // Don't send the message back to the sender
		{
			sendLine(*(it->second), msg + "\r\n");
			std::cout << msg << std::endl;
		}
	}
}

void Channel::addMember(Client* client)
{
	_members.insert(std::pair<std::string, Client*>(client->getNick(), client));
	_clientNum++;
}

void Channel::addOperator(Client* client)
{
	_operators.insert(std::pair<std::string, Client*>(client->getNick(), client));
}

void Channel::removeMember(Client* client)
{
	_members.erase(client->getNick());
	_clientNum--;
}

void Channel::removeOperator(Client* client)
{
	(void)client;
	_operators.erase(client->getNick());
}

std::string Channel::getName() const { return _name; }

Client	*Channel::getMembers(std::string	name)
{
	std::map<std::string, Client *>::iterator	it;

	it = _members.find(name);
	if (it == _members.end())
		return (NULL);
	return (it->second);
}

Client* Channel::getOperators(std::string name)
{
	std::map<std::string, Client *>::iterator	it;

	it = _operators.find(name);
	if (it == _operators.end())
		return (NULL);
	return (it->second);
}

std::map<std::string, Client *> &Channel::getMapOperators()
{
	return _operators;
}

void	Channel::setPassword(const std::string key){
	_password = key;
}

void	Channel::setMode(const std::string mode)
{
	_mode = mode;
	for (size_t i = 0; i < mode.size(); i++)
	{
		if (mode[i] == 'i')
			_inviteMode = true;
		if (mode[i] == 't')
			_topicRestrictionMode = true;
		if (mode[i] == 'k')
			_passwordMode = true;
		if (mode[i] == 'o')
			_operPrivilegeMode = true;
		if (mode[i] == 'l')
			_userLimitMode = true;
	}
}

void	Channel::setChanOperator(Client *creator)
{
	_chanOperator = creator;
}

std::map<std::string, Client *>	&Channel::getMapMembers()
{
	return (_members);
}

std::string	Channel::getTopic(){
	return _topic;
}

int	Channel::authorizedToJoin(Client *client, std::string key)
{
	(void)client;
	if (_passwordMode) // (+k)
	{
		if (key.empty() || key != _password)
			return (475); // ERR_BADCHANNELKEY
	}
	if (_clientNum + 1 >= _userLimit) // (+l)
		return (471); // ERR_CHANNELISFULL

	if (_inviteMode)  //(+i)
		return (473); // ERR_INVITEONLYCHAN
	
	if (_topicRestrictionMode /*&& //cliente no es channel operator*/)
		return (482); // no puede cambiar el _topic -> ERR_CHANOPRIVSNEEDED 482 
	
	return (0);
}

bool Channel::isMember(Client *c) const
{
    return _members.find(c->getNick()) != _members.end();
}

bool Channel::isOperator(Client *c) const
{
    return _operators.find(c->getNick()) != _operators.end()
           || (_chanOperator && _chanOperator == c);
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Client.cpp                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: atudor <marvin@42.fr>                      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/25 15:27:37 by atudor            #+#    #+#             */
/*   Updated: 2025/06/25 15:27:39 by atudor           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../inc/Client.hpp"

Client::Client(int fd)
{
	_nickName = "";
	_userName = "";
	_buffer = "";
	_host = "";
	_fd = fd;
	_registryState = false;
	_handShake = false;
	_isChannelOper = false;
	_isServerOper = false;
	_isNetCat = false;
	_channelsJoined = 0;
	memset(&_addr, 0, sizeof(_addr));
	_channels = std::map<std::string, Channel *>();
}

Client::Client(const Client &other) :
	_nickName(other._nickName),
	_userName(other._userName),
	_buffer(other._buffer),
	_host(other._host),
	_fd(other._fd),
	_registryState(other._registryState),

	_handShake(other._handShake),
	_isChannelOper(other._isChannelOper),
	_isServerOper(other._isServerOper),
	_connectionTime(other._connectionTime),
	_isNetCat(other._isNetCat),
	_channelsJoined(other._channelsJoined),
	_addr(other._addr),
	_channels(other._channels)
{}

Client::~Client() {}

Client &Client::operator=(const Client &other)
{
	if (this != &other)
	{
		_fd = other._fd;
		_registryState = other._registryState;
		_handShake = other._handShake;
		_nickName = other._nickName;
		_userName = other._userName;
		_buffer = other._buffer;
		_host = other._host;
		_isServerOper = other._isServerOper;
		_isChannelOper = other._isChannelOper;
		_connectionTime = other._connectionTime;
		_isNetCat = other._isNetCat;
		_channelsJoined = other._channelsJoined;
		_addr = other._addr;
		_channels = other._channels;
	}
	return *this;
}

std::string &Client::getNick() { return _nickName; }
std::string &Client::getUser() { return _userName; }
std::string &Client::getBuffer() { return _buffer; }
std::string &Client::getIp() { return _host; }
std::map<std::string, Channel *> &Client::getChannels() { return _channels; }
int &Client::getFd() { return _fd; }
bool Client::getRegistryState() { return _registryState; }
bool Client::getHandShake() { return _handShake; }
bool Client::getServerOper() { return _isServerOper; }
int &Client::getChannelsJoined() { return _channelsJoined; }
time_t Client::getConnectionTime() const { return _connectionTime; }
bool Client::getIsNetCat() const { return _isNetCat; }
struct sockaddr_in &Client::getAddr(void) { return (_addr); }

void Client::setNick(std::string nick) { _nickName = nick; }
void Client::setUser(std::string user) { _userName = user; }
void Client::setBuffer(std::string buf)
{
    std::string filtered;
    filtered.reserve(buf.size());
    for (std::string::iterator it = buf.begin(); it != buf.end(); ++it)
    {
        if (static_cast<unsigned char>(*it) != 4)
            filtered += *it;
    }
    _buffer += filtered;
}
void Client::setFd(int fd) { _fd = fd; }
void Client::setHost(std::string host) { _host = host; }
void Client::setHandShake(bool state) { _handShake = state; }
void Client::setChannels(std::map<std::string, Channel*> _channels) { this->_channels = _channels; }
void Client::setRegistryState(bool state) { _registryState = state; }
void Client::setServerOper(bool state) { _isServerOper = state; }
void Client::setConnectionTime(time_t time) { _connectionTime = time; }
void Client::setIsNetCat(bool state) { _isNetCat = state; }
void Client::setAddr(struct sockaddr_in addr) { _addr = addr; }


void	Client::addJoinedChannel(Channel *joinedChannel)
{
	_channels.insert(std::pair<std::string, Channel *>(joinedChannel->getName(), joinedChannel));
	_channelsJoined++;
}

void	Client::removeJoinedChannel(Channel *joinedChannel)
{
	_channels.erase(joinedChannel->getName());
	_channelsJoined--;
}
#include "../inc/Server.hpp"
#include "../inc/Client.hpp"
#include "../inc/Channel.hpp"

void	Server::executeCmd(Client &client, std::string cmd, std::vector<std::string> args)
{
	int code = 0;
	args.erase(args.begin());
	// std::cout << "nick = " << client.getNick() << std::endl;
	// std::cout << "pass = " << client.getRegistryState() << std::endl;
	// std::cout << "user = " << client.getUser() << std::endl;

	if(isCommand(cmd) == UNKNOWN && cmd != "CAP" && cmd != "WHO")
		return (errorReply(client, 421, cmd, args), void());
	else if (!client.getHandShake() && isCommand(cmd) != PASS && isCommand(cmd) != NICK && isCommand(cmd) != USER && cmd != "CAP" && cmd != "WHO")
		return(errorReply(client, 451, cmd, args), void());
	if(isCommand(cmd) == NICK || isCommand(cmd) == USER || isCommand(cmd) == PASS)
	{
		if (isCommand(cmd) == NICK)
			code = nickCmd(client, args);
		else if (isCommand(cmd) == USER)
			code = userCmd(client, args);
		else if (isCommand(cmd) == PASS)
			code = passCmd(client, args);
		if((client.getRegistryState() && client.getNick() != "" && client.getUser() != "") && !client.getHandShake())
			handshake(client);
		std::cout << RED << "[" << code << "] " << RESET << std::endl;
		if (code)
			errorReply(client, code, cmd, args);
		return ;
	}
	switch (isCommand(cmd))
	{
		case NICK: code = nickCmd(client, args); break;
		case USER: code = userCmd(client, args); break;
		case PASS: code = passCmd(client, args); break;
		case JOIN: code = joinCmd(client, args); break;
		case PART: break;//code = partCmd(client, args); break;
		case TOPIC: break;// code = topic(client, args); break;
		case INVITE: break;// code = invite(client, args); break;
		case KICK: break; code = kickCmd(client, args); break;
		case MODE: break;// code =mode(client, args); break;
		case OPER: code = operCmd(client, args); break;
		case PRIVMSG: code = privmsgCmd(client, args); break;
		case HELP: code = helpCmd(client, args); break;
		case DIE: code = dieCmd(client, args); break;
		case QUIT: code = quitCmd(client, args); break;
		case UNKNOWN:
		{
			if(cmd == "WHO" || cmd == "CAP")
				return;
				// ERR_UNKNOWNCOMMAND (421) (send to client)
			code = 421;
			std::cout << cmd << ": Unknow command\n";
		}
	}
	if (code)
		errorReply(client, code, cmd, args);
}

Channel	*Server::getChannel(const std::string	&name)
{
	std::map<std::string, Channel *>::iterator	it;

	it = _channels.find(name);
	if (it == _channels.end())
		return (NULL);
	return (it->second);
}

CommandType Server::isCommand(const std::string &cmd)
{
	if (cmd == "PASS") return (PASS);
	else if (cmd == "NICK") return (NICK);
	else if (cmd == "USER") return (USER);
	else if (cmd == "QUIT") return (QUIT);
	else if (cmd == "HELP" || cmd == "WELP" || cmd == "welp") return (HELP);
	else if (cmd == "JOIN") return (JOIN);
	else if (cmd == "PART") return (PART);
	else if (cmd == "TOPIC") return (TOPIC);
	else if (cmd == "INVITE") return (INVITE);
	else if (cmd == "KICK") return (KICK);
	else if (cmd == "MODE") return (MODE);
	else if (cmd == "OPER" || cmd == "oper") return (OPER);
	else if (cmd == "PRIVMSG" || cmd == "privmsg")return (PRIVMSG);
	else if (cmd == "DIE") return (DIE);
	// else if (cmd == "CAP") return (CAP);
	else
		return (UNKNOWN);
}
#include "../inc/Server.hpp"

bool sendLine(Client &cli, const std::string &line)
{
	const char *data;
	size_t left;
	ssize_t n;

	data = line.c_str();
	left = line.size();
	// n = send(cli.getFd(), line.c_str(), line.size(), 0);
	// if (n == -1)
	// {
	// 	if (errno == EAGAIN || errno == EWOULDBLOCK)
	// 		return false;
	// 	perror("send");
	// 	return false;
	// }
	while (left)
	{
		n = send(cli.getFd(), data, left, MSG_DONTWAIT | MSG_NOSIGNAL);
		if (n == -1)
		{
			if (errno == EAGAIN || errno == EWOULDBLOCK)
				continue;
			perror("send");
			return false;
		}
		left  -= n;
		data  += n;
	}
	return true;
}

std::string Server::itoa3(int code)
{
	std::ostringstream oss;

	if (code < 10)
		oss << "00";
	else if (code < 100)
		oss << '0';
	oss << code;
	return oss.str();
}

bool Server::reply(Client &cli, int code, const std::string &params, const std::string &text)
{
	std::string line = ":" + _hostname + " " + itoa3(code) + " " + cli.getNick() + " ";
    if (!params.empty())
        line += " " + params;
    if (!text.empty())
        line += ":" + text;
    line += "\r\n";
	return (sendLine(cli, line));
}

void Server::handshake(Client &c)
{
    c.setHandShake(true);

    time_t now = time(NULL);
    char   datebuf[64];

	if(difftime(time(NULL), c.getConnectionTime()) > 2)
		c.setIsNetCat(true);
    strftime(datebuf, sizeof datebuf, "%d-%b-%Y %H:%M:%S %Z", localtime(&now));

    reply(c, 1,  "", "Welcome to the " + _hostname + " Network " + c.getNick() + "!~" + c.getUser() + "@" + _hostname);
    reply(c, 2,  "", "Your host is " + _hostname + ", running version 0.1");
    reply(c, 3,  "", "This server was created " + std::string(datebuf));
    reply(c, 4,  _hostname + " 0.1 aiwro imnptkol", "");
    reply(c, 5,  "CHANTYPES=# CHANMODES=,ntkl", "are supported by this server");

    std::cout << GREEN << "[fd " << c.getFd() << "] handshake sent" << RESET << '\n';
}

void Server::errorReply(Client &cli, int code, std::string str, std::vector<std::string> args)
{
	std::string line = ":" + _hostname + " " + itoa3(code) + " " + (cli.getNick().empty() ? "*" : cli.getNick()) + " :" ;
	switch (code)
	{
		case 000: return; // No error
		case 401: line += str + ": No such nick/channel"; break;
		case 403: line += args[0] + ": No such channel"; break;
		case 411: line += "No recipient given (" + str + ")"; break;
		case 412: line += "No text to send"; break;
		case 421: line += "[" + str + "]: Unknown command"; break;
		case 433: line += args[0] + ": Nickname is already in use"; break;
		case 451: line += "You have not registered"; break;
		case 461: line += "[" + str + "]: Not enough parameters"; break;
		case 462: line += "You may not reregister"; break;
		case 464: line += "Password incorrect"; break;
		case 481: line += "Permission Denied- You're not an IRC operator"; break;
		case 524: line = args[0] + ": No help available on this topic"; break;
		case 441: line += args[1] + " " + args[0] + " :They aren't on that channel"; break;
		case 442: line += args[0] + " :You're not on that channel"; break;
		case 482: line += args[0] + " :You're not channel operator"; break;
		case 471: line += args[0] + " :Cannot join channel (+l)";break;
        case 473:line += args[0] + " :Cannot join channel (+i)";break;
        case 475:line += args[0] + " :Cannot join channel (+k)";break;
		default: line += "Unknown error";
	}
	line +=  "\r\n";
	sendLine(cli, line);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.cpp                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: atudor <marvin@42.fr>                      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/25 15:26:39 by atudor            #+#    #+#             */
/*   Updated: 2025/07/08 20:05:17 by atudor           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../inc/Server.hpp"
#include <cstdlib>
#include <iostream>
#include <csignal>

static Server *g_server = NULL;

static void handleSignal(int)
{
    if (g_server)
        g_server->stop();
}

static unsigned short parsePort(const char *arg)
{
    char *end;
	long port;

	end = NULL;
    port = std::strtol(arg, &end, 10);
    if (*end != '\0' || port <= 0 || port > 65535)
		return (0);
    return (static_cast<unsigned short>(port));
}

int main(int argc, char **argv)
{
	unsigned short port;
	std::string pass;

    if (argc != 3)
    {
        std::cerr << "Usage: ./ircserv <port> <password>\n";
        return EXIT_FAILURE;
    }

    port = parsePort(argv[1]);
    if (!port)
    {
        std::cerr << "Invalid port\n";
        return EXIT_FAILURE;
    }
    pass = argv[2];
    Server srv(port, pass);
	g_server = &srv;

    struct sigaction sa;
    sa.sa_handler = handleSignal;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;
    sigaction(SIGINT, &sa, NULL);
    sigaction(SIGTERM, &sa, NULL);
    srv.run();
    return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Server.cpp                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: atudor <marvin@42.fr>                      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/25 15:27:45 by atudor            #+#    #+#             */
/*   Updated: 2025/07/08 21:22:39 by atudor           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../inc/Server.hpp"
#include "../inc/Client.hpp"
#include "../inc/Channel.hpp"

Server::Server(unsigned short port, const std::string &password)
    : _port(port), _password(password), _listenFd(-1), _running(false)
{
    _operator_credentials["cris"]  = "mandarino";
    _operator_credentials["marta"] = "voley";
    _operator_credentials["stefi"] = "taylor";

}

Server::~Server()
{
	// Close all sockets and free Client / Channel objects
	for (std::vector<struct pollfd>::iterator it = _pollFds.begin(); it != _pollFds.end(); ++it)
		if (it->fd >= 0)
			close(it->fd);

	for (std::map<int, Client *>::iterator it = _clients.begin(); it != _clients.end(); ++it)
		delete it->second;
	for (std::map<std::string, Channel *>::iterator it = _channels.begin(); it != _channels.end(); ++it)
		delete it->second;
}

void Server::initListeningSocket()
{
	int opt;
	struct sockaddr_in addr;
	struct pollfd pfd;
	char  hostnameStr[256];

	if (gethostname(hostnameStr, sizeof(hostnameStr)) == -1)
		throw std::runtime_error("initConnection: gethostname()");
	_hostname = hostnameStr;
	_listenFd = socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, 0);
	if (_listenFd == -1)
	{
		perror("socket");
		exit(EXIT_FAILURE);
	}

	opt = 1;
	setsockopt(_listenFd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

	std::memset(&addr, 0, sizeof(addr));
	addr.sin_family = AF_INET;
	addr.sin_addr.s_addr = INADDR_ANY;
	addr.sin_port = htons(_port);

	if (bind(_listenFd, reinterpret_cast<struct sockaddr *>(&addr), sizeof(addr)) == -1)
	{
		perror("bind");
		exit(EXIT_FAILURE);
	}

	if (listen(_listenFd, 10) == -1)
	{
		perror("listen");
		exit(EXIT_FAILURE);
	}

	pfd.fd = _listenFd;
	pfd.events = POLLIN;
	pfd.revents = 0;
	_pollFds.push_back(pfd);
}

void Server::acceptNewClient()
{
	// should we remove the while()?
	while (true)
	{
		struct sockaddr_in cliAddr;
		socklen_t len = sizeof(cliAddr);
		int fd = accept(_listenFd, reinterpret_cast<struct sockaddr *>(&cliAddr), &len);

		if (fd == -1)
		{
			if (errno == EAGAIN || errno == EWOULDBLOCK)
				break;
			perror("accept");
			return;
		}

		_clients[fd] = new Client(fd);
		struct pollfd pfd = {fd, POLLIN, 0};
		_clients[fd]->setAddr(cliAddr);
		_clients[fd]->getAddr().sin_family = AF_INET;
		_clients[fd]->getAddr().sin_port = htons(_port); // Port is not set here, it will be set later
		_pollFds.push_back(pfd);
		_clients[fd]->setConnectionTime(time(NULL));
		std::cout << "[+] Client connected fd=" << fd << "\n";
}
}

void Server::handleClientData(size_t idx)
{
	int    fd = _pollFds[idx].fd;
	Client *c  = _clients[fd];
	char   buf[1024];

	ssize_t bytes = recv(fd, buf, sizeof(buf), MSG_DONTWAIT);
	if (bytes == -1)
	{
		if (errno == EAGAIN || errno == EWOULDBLOCK)
			return;
		perror("recv");
		removeClient(idx);
		return;
	}
	if (bytes == 0)
	{
		std::cout << "[i] Client closed fd=" << fd << '\n';
		removeClient(idx);
		return;
	}
	else if (bytes > 1024)
	{
		std::cerr << "[!] Warning: Received more than 1024 bytes, weird things might happen ((>.<)).\n";
	}

	/* ► Aggregate partial packets ◄ */
	c->getBuffer().append(buf, static_cast<size_t>(bytes));

	/* Process as soon as we have at least one full IRC line (ends “\r\n”). */
	if (c->getBuffer().find("\r\n") != std::string::npos)
		processBuffer(c);    // consumes complete lines, keeps any tail
}


void Server::removeClient(size_t idx)
{
	int fd = _pollFds[idx].fd;

	if (_clients.count(fd)) {
		close(fd);
		delete _clients[fd];
		_clients.erase(fd);
	}
	if (idx != _pollFds.size() - 1)
		_pollFds[idx] = _pollFds.back();
	_pollFds.pop_back();
}

void Server::processBuffer(Client *c)
{
	std::string &buf = c->getBuffer();
	std::vector<std::string> msgs;
	size_t pos;

	while ((pos = buf.find("\r\n")) != std::string::npos)
	{
		msgs.push_back(buf.substr(0, pos));
		buf.erase(0, pos + 2);
	}
	for (std::vector<std::string>::iterator it = msgs.begin(); it != msgs.end(); ++it)
	{
		std::istringstream iss(*it);
		std::string token;
		std::vector<std::string> args;

		while (iss >> token)
		{
			if (token[0] == ':')
			{
				std::string rest;
				std::getline(iss, rest);
				token += rest;
				if (!token.empty() && token[1] == ' ')
					token.erase(1, 1);
			}
			args.push_back(token);
		}
		if (!args.empty())
			executeCmd(*c, args[0], args);
	}
}


void Server::run()
{
	initListeningSocket();
	_running = true;
	std::cout << "[+] Listening on port " << _port << " (Linux)" << std::endl;

	while (_running)
	{
		if (_pollFds.empty()) {
			std::cerr << "ERROR: pollFds is empty! This should never happen.\n";
			break;
		}
		if (poll(&_pollFds[0], _pollFds.size(), -1) == -1)
		{
			if (errno == EINTR)
				continue;
			perror("poll");
			break;
		}

		if (_pollFds[0].revents & POLLIN)
			acceptNewClient();

		for (ssize_t i = _pollFds.size() - 1; i >= 1; --i)
		{
			if (_pollFds[i].revents & POLLIN)
			{
				handleClientData(i);
				continue;
			}

			if (_pollFds[i].revents & (POLLERR | POLLHUP | POLLNVAL))
			{
				removeClient(i);
				continue;
			}
		}

		// std::cout << "Current poll fds:\n";
		// for (size_t i = 0; i < _pollFds.size(); ++i)
		// 	std::cout << "  [" << i << "] fd=" << _pollFds[i].fd << "\n";
	}
}

void Server::stop()
{
        _running = false;
}
#include "../inc/Channel.hpp"
# include "../inc/Client.hpp"
# include "../inc/Server.hpp"


Channel::Channel(std::string name) {
	_name = name;
	_clientNum = 0;
	_password = "";
	_userLimit = 0;
	_chanOperator = NULL;
	_topic = "";
	_mode = "";
	_accessType = "";
	_invitedMembers.clear();
	_passwordMode = false;
	_inviteMode = false;
	_topicRestrictionMode = true;
	_operPrivilegeMode = false;
	_userLimitMode = false;
	//members = std::map<int, Client *>();
}

Channel::Channel(const Channel &other) :
	_name(other._name),
	_password(other._password),
	_clientNum(other._clientNum),
	_topic(other._topic),
	_userLimit(other._userLimit),
	_invitedMembers(other._invitedMembers),
	_mode(other._mode),
	_chanOperator(other._chanOperator),
	_accessType(other._accessType),
	_members(other._members),
	_operators(other._operators)
{}

Channel::~Channel() {}

Channel &Channel::operator=(const Channel &other) {
	if (this != &other) {
		_name = other._name;
		_clientNum = other._clientNum;
		_chanOperator = other._chanOperator;
		_userLimit = other._userLimit;
		_topic = other._topic;
		_password = other._password;
		_mode = other._mode;
		_accessType = other._accessType;
		_members = other._members;
		_operators = other._operators;
		_invitedMembers = other._invitedMembers;
	}
	return *this;
}

void	Channel::broadcast(std::string msg, Client &except)
{
	for(std::map<std::string, Client *>::iterator it = _members.begin(); it != _members.end(); ++it)
	{
		if (it->first != except.getNick()) // Don't send the message back to the sender
		{
			sendLine(*(it->second), msg + "\r\n");
			std::cout << msg << std::endl;
		}
	}
}

void Channel::addMember(Client* client)
{
	_members.insert(std::pair<std::string, Client*>(client->getNick(), client));
	_clientNum++;
}

void Channel::addOperator(Client* client)
{
	_operators.insert(std::pair<std::string, Client*>(client->getNick(), client));
}

void Channel::removeMember(Client* client)
{
	_members.erase(client->getNick());
	_clientNum--;
}

void Channel::removeOperator(Client* client)
{
	(void)client;
	_operators.erase(client->getNick());
}

std::string Channel::getName() const { return _name; }

Client	*Channel::getMembers(std::string	name)
{
	std::map<std::string, Client *>::iterator	it;

	it = _members.find(name);
	if (it == _members.end())
		return (NULL);
	return (it->second);
}

Client* Channel::getOperators(std::string name)
{
	std::map<std::string, Client *>::iterator	it;

	it = _operators.find(name);
	if (it == _operators.end())
		return (NULL);
	return (it->second);
}

std::map<std::string, Client *> &Channel::getMapOperators()
{
	return _operators;
}

void	Channel::setPassword(const std::string key){
	_password = key;
}

void	Channel::setMode(const std::string mode)
{
	_mode = mode;
	for (size_t i = 0; i < mode.size(); i++)
	{
		if (mode[i] == 'i')
			_inviteMode = true;
		if (mode[i] == 't')
			_topicRestrictionMode = true;
		if (mode[i] == 'k')
			_passwordMode = true;
		if (mode[i] == 'o')
			_operPrivilegeMode = true;
		if (mode[i] == 'l')
			_userLimitMode = true;
	}
}

void	Channel::setChanOperator(Client *creator)
{
	_chanOperator = creator;
}

std::map<std::string, Client *>	&Channel::getMapMembers()
{
	return (_members);
}

std::string	Channel::getTopic(){
	return _topic;
}

int	Channel::authorizedToJoin(Client *client, std::string key)
{
	(void)client;
	if (_passwordMode) // (+k)
	{
		if (key.empty() || key != _password)
			return (475); // ERR_BADCHANNELKEY
	}
	if (_clientNum + 1 >= _userLimit) // (+l)
		return (471); // ERR_CHANNELISFULL

	if (_inviteMode)  //(+i)
		return (473); // ERR_INVITEONLYCHAN
	
	if (_topicRestrictionMode /*&& //cliente no es channel operator*/)
		return (482); // no puede cambiar el _topic -> ERR_CHANOPRIVSNEEDED 482 
	
	return (0);
}

bool Channel::isMember(Client *c) const
{
    return _members.find(c->getNick()) != _members.end();
}

bool Channel::isOperator(Client *c) const
{
    return _operators.find(c->getNick()) != _operators.end()
           || (_chanOperator && _chanOperator == c);
}#include "../../inc/Server.hpp"

int Server::nickCmd(Client &client, std::vector<std::string> args)
{
    if (args.empty())
        return 461; // ERR_NEEDMOREPARAMS

    const std::string &newNick = args[0];

    // 1. refuse if the nick is already taken
    for (std::map<int, Client*>::iterator it = _clients.begin(); it != _clients.end(); ++it)
        if (it->second->getNick() == newNick)
            return 433; // ERR_NICKNAMEINUSE

    std::string oldNick = client.getNick();
    if (oldNick == newNick)
        return 0;

    client.setNick(newNick);

    // 2. build the NICK message once so we can reuse it
    std::string nickMsg = ":" + oldNick + "!" + client.getUser() + "@" +
                          client.getIp() + " NICK :" + newNick;

    // 3. tell the user themselves
    sendLine(client, nickMsg + "\r\n");

    // 4. update every channel’s bookkeeping and broadcast to everyone there
    std::map<std::string, Channel*>& chans = client.getChannels();
    for (std::map<std::string, Channel*>::iterator chanPair = chans.begin(); chanPair != chans.end(); ++chanPair)
    {
        Channel *chan = chanPair->second;

        // rename inside members/ops maps
        chan->getMapMembers().erase(oldNick);
        chan->getMapMembers()[newNick] = &client;

        std::map<std::string, Client *> &ops = chan->getMapOperators();
        if (ops.erase(oldNick))
            ops[newNick] = &client;

        // send to all members, *including* the origin
        chan->broadcast(nickMsg,client);
    }

    return 0;
}#include "../../inc/Server.hpp"

int Server::dieCmd(Client &client, std::vector<std::string> args)
{
	(void)args;
	if (client.getServerOper() == false)
	{
		// ERR_NOPRIVILEGES (481) -> "<client> :Permission Denied- You're not an IRC operator"
		std::cerr << "[" << client.getFd() << "] DIE: You are not an operator!\n";
		return (481);
	}
	std::map<int, Client *>::iterator it;
	for(it = _clients.begin(); it != _clients.end(); ++it)
	{
		reply(*it->second, 400, "", "Server is shutting down. Goodbye!");
		std::cout << "Notifying client fd " << it->second->getFd() << " about server shutdown...\n";
	}
	stop();
	return (0);
}
#include "../../inc/Server.hpp"


int Server::helpCmd(Client &client, std::vector<std::string> args)
{
	if(args.empty())
	{
		sendLine(client, "\r\n");
		sendLine(client, ":" + _hostname + " 704 " + client.getNick() + " index " + ": Commands Available:\r\n");
		sendLine(client, "\r\n");
		sendLine(client, ":" + _hostname + " 705 " + client.getNick() + " index " + ": NICK\t\tUSER\t\tPASS   \t\tQUIT\r\n");
		sendLine(client, ":" + _hostname + " 705 " + client.getNick() + " index " + ": JOIN\t\tPART\t\tTOPIC  \t\tINVITE\r\n");
		sendLine(client, ":" + _hostname + " 705 " + client.getNick() + " index " + ": KICK\t\tMODE\t\tPRIVMSG\t\tOPER\r\n");
		sendLine(client, "\r\n");
		sendLine(client, ":" + _hostname + " 706 " + client.getNick() + " index " + ": Type /WELP <command> for more information, or /WELP -l\r\n");
		sendLine(client, "\r\n");
	}
	else if (args[0] == "-l")
	{
		sendLine(client, "\r\n");
		sendLine(client, " Commands Available:\r\n");
		sendLine(client, (client.getIsNetCat() ? std::string(RED) : std::string("\00304")) + "\t NICK" + (client.getIsNetCat() ? std::string(RESET) : std::string("\017")) + " : Usage: NICK <nickname>, sets your nick\r\n");
		sendLine(client, (client.getIsNetCat() ? std::string(RED) : std::string("\00304")) + "\t USER" + (client.getIsNetCat() ? std::string(RESET) : std::string("\017")) + " : Usage: USER <username> <hostname> <servername> :<realname>\r\n");
		sendLine(client, (client.getIsNetCat() ? std::string(RED) : std::string("\00304")) + "\t PASS" + (client.getIsNetCat() ? std::string(RESET) : std::string("\017")) + " : Usage: PASS <password>\r\n");
		sendLine(client, (client.getIsNetCat() ? std::string(RED) : std::string("\00304")) + "\t QUIT" + (client.getIsNetCat() ? std::string(RESET) : std::string("\017")) + " : Usage: QUIT [<reason>], disconnects from the current server\r\n");
		sendLine(client, (client.getIsNetCat() ? std::string(RED) : std::string("\00304")) + "\t JOIN" + (client.getIsNetCat() ? std::string(RESET) : std::string("\017")) + " : Usage: JOIN <channel>, joins the channel\r\n");
		sendLine(client, (client.getIsNetCat() ? std::string(RED) : std::string("\00304")) + "\t PART" + (client.getIsNetCat() ? std::string(RESET) : std::string("\017")) + " : Usage: PART [<channel>] [<reason>], leaves the channel, by default the current one\r\n");
		sendLine(client, (client.getIsNetCat() ? std::string(RED) : std::string("\00304")) + "\t TOPIC" + (client.getIsNetCat() ? std::string(RESET) : std::string("\017")) + " : Usage: TOPIC [<topic>], sets the topic if one is given, else shows the current topic\r\n");
		sendLine(client, (client.getIsNetCat() ? std::string(RED) : std::string("\00304")) + "\t INVITE" + (client.getIsNetCat() ? std::string(RESET) : std::string("\017")) + " : Usage: INVITE <nick> [<channel>], invites someone to a channel, by default the current channel (needs chanop)\r\n");
		sendLine(client, (client.getIsNetCat() ? std::string(RED) : std::string("\00304")) + "\t KICK" + (client.getIsNetCat() ? std::string(RESET) : std::string("\017")) + " :  Usage: KICK <channel> <user>[,user2...] [reason]\r\n");
		sendLine(client, (client.getIsNetCat() ? std::string(RED) : std::string("\00304")) + "\t MODE" + (client.getIsNetCat() ? std::string(RESET) : std::string("\017")) + " : Usage: MODE <channel> [<mode>]\r\n");
		sendLine(client, (client.getIsNetCat() ? std::string(RED) : std::string("\00304")) + "\t PRIVMSG" + (client.getIsNetCat() ? std::string(RESET) : std::string("\017")) + " : Usage: PRIVMSG <target> :<message>\r\n");
		sendLine(client, (client.getIsNetCat() ? std::string(RED) : std::string("\00304")) + "\t OPER" + (client.getIsNetCat() ? std::string(RESET) : std::string("\017")) + " : Usage: OPER <username> <password>, grants operator privileges\r\n");
		sendLine(client, "\r\n");
		sendLine(client, " Type /WELP <command> for more information, or /WELP -l\r\n");
		sendLine(client, "\r\n");
	}
	else
	{
		sendLine(client, "\r\n");
		sendLine(client, (client.getIsNetCat() ? std::string(RED) : std::string("\00304")) + " Usage\r\n" + (client.getIsNetCat() ? std::string(RESET) : std::string("\017")));

		if (args[0] == "NICK" || args[0] == "nick")
			sendLine(client, "\t\tNICK <nickname>, sets your nick\r\n");
		else if (args[0] == "USER" || args[0] == "user")
			sendLine(client, "\t\tUSER <username> <hostname> <servername> :<realname>\r\n");
		else if (args[0] == "PASS" || args[0] == "pass")
			sendLine(client, "\t\tPASS <password>\r\n");
		else if (args[0] == "QUIT" || args[0] == "quit")
			sendLine(client, "\t\tQUIT [<reason>], disconnects from the current server\r\n");
		else if (args[0] == "JOIN" || args[0] == "join")
			sendLine(client, "\t\tJOIN <channel>, joins the channel\r\n");
		else if (args[0] == "PART" || args[0] == "part")
			sendLine(client, "\t\tPART [<channel>] [<reason>], leaves the channel, by default the current one\r\n");
		else if (args[0] == "TOPIC" || args[0] == "topic")
			sendLine(client, "\t\tTOPIC [<topic>], sets the topic if one is given, else shows the current topic\r\n");
		else if (args[0] == "INVITE" || args[0] == "invite")
			sendLine(client, "\t\tINVITE <nick> [<channel>], invites someone to a channel, by default the current channel (needs chanop)\r\n");
		else if (args[0] == "KICK" || args[0] == "kick")
			sendLine(client, "\t\tKICK <nick> [reason], kicks the nick from the current channel (needs chanop)\r\n");
		else if (args[0] == "MODE" || args[0] == "mode")
			sendLine(client, "\t\tMODE <channel> [<mode>]\r\n");
		else if (args[0] == "PRIVMSG" || args[0] == "privmsg")
			sendLine(client, "\t\tPRIVMSG <target> :<message>\r\n");
		else if (args[0] == "OPER" || args[0] == "oper")
			sendLine(client, "\t\tOPER <username> <password>, grants operator privileges\r\n");
		else
		{
			// ERR_HELPNOTFOUND (524) -> "client> <subject> :No help available on this topic"
			std::cerr << "[" << client.getFd() << "] HELP: No help available on this topic\n";
			return (524);
		}
	}
	return (0);
}#include "../../inc/Server.hpp"

std::vector<std::string> vectorSplit(const std::string& str, char delim)
{
    std::vector<std::string> tokens;
    std::string token;
    std::stringstream ss(str);

    while (std::getline(ss, token, delim))
	{
        tokens.push_back(token);
    }
    return (tokens);
}

void	Server::createChannel(std::string channelName, std::string key, Client *client)
{
	Channel *newChannel = new Channel(channelName);

	if (!key.empty())
		newChannel->setPassword(key);
	newChannel->addMember(client);
	newChannel->addOperator(client);
	newChannel->setChanOperator(client);
	newChannel->setMode("Cnst");

	_channels[channelName] = newChannel;
}

std::map<std::string, std::string>	*Server::parseJoinArgs(std::vector<std::string> args)
{
	std::map<std::string, std::string>	*joins;
	joins = new std::map<std::string, std::string>;

	std::vector<std::string> channels = vectorSplit(args[0], ',');
    std::vector<std::string> keys;
    if (args.size() > 1)
		keys = vectorSplit(args[1], ',');
	std::string	channelKey;
    for (size_t i = 0; i < channels.size(); ++i)
	{
		if (i < keys.size())
			channelKey = keys[i];
		else
			channelKey = "";
        (*joins)[channels[i]] = channelKey;
		//joins[channels[i]].insert(channelKey);
		std::cout << "channel " << channels[i] << ", key: " << channelKey << std::endl;
	}
	return (joins);
}

int	Server::joinCmd(Client &client, std::vector<std::string> args)
{
	std::cout << "ip : " << client.getIp() << std::endl;
	std::map<std::string, std::string>	*joins;

	// std::cout << "heyy im in joinn\n";

	if (!client.getRegistryState())
	{
		//ERR_NOTREGISTERED (451)
		std::cout << "You haven't registered yet!\n";
		return (451);
	}
	if (!args.size())
		return 461;
	if (args.size() == 1 && args[0] == "0")
	{
		//partCmd(client, NULL);
		std::cout << "should be parting from all channels he is in\n";
		return (0);
	}
	joins = parseJoinArgs(args);
	if (!joins)
		return (0);
	
	std::map<std::string, std::string>::iterator	joins_it = joins->begin();
	while (joins_it != joins->end())
	{
		std::string	channel = joins_it->first;
		std::string	key = joins_it->second;
		if (!getChannel(joins_it->first)) // si no encuentras el canal
		{

			if (channel[0] != '#')
			{
				//ERR 403 -> "there is no such channel"
				delete joins;
				return (403);
			}
			else
			{
				createChannel(channel, key, &client);
				client.addJoinedChannel(getChannel(channel));
				// std::string	arg = "JOIN " + channel;
				// std::string arg = ":" + client.getNick() + "!" + client.getUser() + "@" + _hostname;
				sendLine(client, ":" + client.getNick() + "!" + client.getUser() + "@" + client.getIp() + " JOIN " + channel + "\r\n");

				// sendLine(client, ":" + client.getNick() + "!" + client.getUser() + "@" + client.getIp() + " JOIN " + channel + " * :" + "Welcome to the channel!\r\n");
				sendLine(client, ":" + _hostname + " 353 " + client.getNick() + " @ " + channel + " :@" + client.getNick() + "\r\n");
				sendLine(client, ":" + _hostname + " 366 " + client.getNick() + " " + channel + " :" + "End of /NAMES list\r\n");

				// RPL_NAMEREPLY 353
				// send RPL_ENDOFNAMES 366
				// reply(client, 0, "", );
			}

		}
		else // el channel ya exise
		{
			if ( client.getChannelsJoined() <= CHANLIMIT - 1)
			{
				// add client to channel
				getChannel(channel)->addMember(&client);
				sendLine(client, ":" + client.getNick() + "!" + client.getUser() + "@" + client.getIp() + " JOIN " + channel + "\r\n");

				// sendLine(client, ":" + client.getNick() + "!" + client.getUser() + "@" + _hostname + " JOIN " + channel + " * :" + "Welcome to the channel!\r\n");
				std::map<std::string, Client *>& members = _channels[channel]->getMapMembers();
				std::string names_list;
				for (std::map<std::string, Client *>::iterator it = members.begin(); it != members.end(); ++it)
				{
					Client* member = it->second; // pointer to the Client object
					std::string member_nick = member->getNick();
					if (!names_list.empty())
						names_list += " ";
					names_list += member_nick;
					// Now you can use member_nick in your reply
					// Example: sendLine(client, ":" + member_nick + "!" + ... );
				}
				if (!getChannel(channel)->getTopic().empty())
				{
					// SEND :molybdenum.libera.chat 332 martaa #holiboli :iwantanothertopic (RPL_TOPIC)
					// SEND 333 (RPL_TOPICWHOTIME)
				}
				sendLine(client, ":" + _hostname + " 353 " + client.getNick() + " @ " + channel + " :@"  + names_list + "\r\n");
				sendLine(client, ":" + _hostname + " 366 " + client.getNick() + " " + channel + " :" + "End of /NAMES list\r\n");
				getChannel(channel)->broadcast(":" + client.getNick() + "!~" + client.getUser() + "@" + client.getIp() + " JOIN " + channel + " :realname", client);
				client.addJoinedChannel(getChannel(channel));
				// for (std::map<std::string, Client *>::iterator members_it = _channels[channel]->getMapMembers().begin(); members_it != _channels[channel]->getMapMembers().end(); members_it++)
				// {
				// 	std::map<std::string, Client *> mapa = _channels[channel]->getMapMembers();
				// 	std::string member_name = getChannel(channel);
				// 	sendLine(client, ":" + client.getNick() + "!" + client.getUser() + "@" + _hostname + );

				// }
			}
			else
			{
				// ERR_TOOMANYCHANNELS (405)
				delete joins;
				return (405);
			}
			int authCode = getChannel(channel)->authorizedToJoin(&client, key);
			if (authCode == 0) // client is authorized to join -> cumplen con: key, client limit , ban - exception, invite-only - exception
				_channels[channel]->addMember(&client);
			// errorReply(authcode);

		}
		joins_it++;
	}
	delete joins;
	return (0);
}
#include "../../inc/Server.hpp"
#include "../../inc/Channel.hpp"

int Server::kickCmd(Client &issuer, std::vector<std::string> args)
{
    if (args.size() < 2)
        return 461;

    const std::string chanName   = args[0];
    const std::string victimNick = args[1];

    Channel *chan = getChannel(chanName);
    if (!chan)                  return 403;
    if (!chan->isMember(&issuer))  return 442;
    if (!chan->isOperator(&issuer)) return 482;

    Client *victim = chan->getMembers(victimNick);
    if (!victim)                 return 441;
    std::string reason;
    if (args.size() > 2)
    {
        reason = args[2];
        for (size_t i = 3; i < args.size(); ++i)
            reason += ' ' + args[i];
    }
    std::string kickLine = ":" + issuer.getNick() + '!' +
                           issuer.getUser() + '@' + issuer.getIp() +
                           " KICK " + chanName + ' ' + victimNick;

    if (!reason.empty())
        kickLine += " :" + reason;

    chan->broadcast(kickLine, issuer);
    sendLine(issuer, kickLine);

    chan->removeMember(victim);
    victim->removeJoinedChannel(chan);

    // /* destroy empty channel */
    // if (chan->getMapMembers().empty())
    // {
    //     _channels.erase(chanName);
    //     delete chan;
    // }
    return 0;
}
#include "../../inc/Server.hpp"

int Server::operCmd(Client &client, std::vector<std::string> args)
{
	//should we cover ERR_NOOPERHOST (491)? (check the hostname/IP of the client)
	if (args.size() < 2)
	{
		// ERR_NEEDMOREPARAMS (461) -> "<command> :Not enough parameters"
		std::cerr << "[" << client.getFd() << "] OPER: Not enough params\n";
		return (461);
	}
	std::map<std::string, std::string>::iterator	it;
	for(it = _operator_credentials.begin(); it != _operator_credentials.end();)
	{
		if (it->first == args[0] && it->second == args[1])
			break;
		it++;
	}
	if (it == _operator_credentials.end())
	{
		// ERR_PASSWDMISMATCH (464) -> "<client> :Password incorrect"
		std::cerr << "[" << client.getFd() << "] OPER: wrong credentials...\n";
		return (464);
	}
	client.setNick(args[0]);
	client.setUser(args[0]);
	client.setServerOper(true);
	// RPL_YOUREOPER (381)
	reply(client, 381, "", (client.getIsNetCat() ? std::string(GREEN) : std::string("\00303")) + "You are now an IRC operator" + (client.getIsNetCat() ? std::string(RESET) : std::string("\017")));
	return (0);
}#include "../../inc/Server.hpp"

